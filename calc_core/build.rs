//! Build script for calc_core
//!
//! Compiles TOML material data files into Rust source code at build time.
//! This enables:
//! - Human-readable TOML source files for easy transcription
//! - Compile-time validation of data
//! - Zero runtime overhead (all data baked into binary)
//! - Clear provenance tracking via sources.toml

use serde::Deserialize;
use std::collections::HashMap;
use std::env;
use std::fs;
use std::path::Path;

fn main() {
    let out_dir = env::var("OUT_DIR").unwrap();
    let manifest_dir = env::var("CARGO_MANIFEST_DIR").unwrap();
    let data_dir = Path::new(&manifest_dir).join("data").join("wood");

    // Rerun if any data files change
    println!("cargo:rerun-if-changed=data/wood");

    // Check if data directory exists (optional during initial setup)
    if !data_dir.exists() {
        eprintln!("Note: data/wood directory not found, skipping TOML compilation");
        generate_empty_module(&out_dir);
        return;
    }

    let mut generated_code = String::new();
    generated_code.push_str("// Auto-generated by build.rs - DO NOT EDIT\n");
    generated_code.push_str("// Source: calc_core/data/wood/*.toml\n\n");

    // Process sawn lumber data
    if let Some(code) = process_sawn_lumber(&data_dir) {
        generated_code.push_str(&code);
    }

    // Process engineered wood data
    if let Some(code) = process_engineered_wood(&data_dir) {
        generated_code.push_str(&code);
    }

    // Write generated code
    let dest_path = Path::new(&out_dir).join("material_data.rs");
    fs::write(&dest_path, generated_code).expect("Failed to write generated code");

    // Also copy to src/generated for inspection during development
    let src_generated = Path::new(&manifest_dir).join("src").join("generated");
    if src_generated.exists() {
        let _ = fs::write(src_generated.join("material_data.rs"),
            "// See target/debug/build/calc_core-.../out/material_data.rs\n// This file is for reference only\n");
    }
}

fn generate_empty_module(out_dir: &str) {
    let code = r#"// Auto-generated by build.rs - DO NOT EDIT
// No data files found - using placeholder

// Sawn lumber data will be generated here once TOML files are added
pub mod sawn_lumber_data {
    // Placeholder - data not yet migrated from hardcoded values
}

// Engineered wood data will be generated here once TOML files are added
pub mod engineered_wood_data {
    // Placeholder - data not yet migrated from hardcoded values
}
"#;
    let dest_path = Path::new(out_dir).join("material_data.rs");
    fs::write(dest_path, code).expect("Failed to write placeholder code");
}

// ============================================================================
// Sawn Lumber Processing
// ============================================================================

#[derive(Debug, Deserialize)]
struct SawnLumberFile {
    metadata: SawnLumberMetadata,
    #[serde(default)]
    species: Vec<SawnLumberSpecies>,
}

#[derive(Debug, Deserialize)]
struct SawnLumberMetadata {
    source: String,
    table: String,
    edition_year: u32,
    #[allow(dead_code)]
    transcribed_by: Option<String>,
    #[allow(dead_code)]
    transcribed_date: Option<String>,
    #[allow(dead_code)]
    notes: Option<String>,
}

#[derive(Debug, Deserialize)]
struct SawnLumberSpecies {
    name: String,
    code: String,
    grades: Vec<SawnLumberGrade>,
}

#[derive(Debug, Deserialize)]
struct SawnLumberGrade {
    name: String,
    code: String,
    #[serde(rename = "Fb")]
    fb_psi: f64,
    #[serde(rename = "Ft")]
    ft_psi: f64,
    #[serde(rename = "Fv")]
    fv_psi: f64,
    #[serde(rename = "Fc_perp")]
    fc_perp_psi: f64,
    #[serde(rename = "Fc")]
    fc_psi: f64,
    #[serde(rename = "E")]
    e_psi: f64,
    #[serde(rename = "Emin")]
    e_min_psi: f64,
    #[serde(rename = "SG")]
    specific_gravity: f64,
}

fn process_sawn_lumber(data_dir: &Path) -> Option<String> {
    let sawn_dir = data_dir.join("sawn_lumber");
    if !sawn_dir.exists() {
        return None;
    }

    let mut all_data: Vec<(SawnLumberMetadata, Vec<SawnLumberSpecies>)> = Vec::new();

    // Process all TOML files in sawn_lumber directory
    if let Ok(entries) = fs::read_dir(&sawn_dir) {
        for entry in entries.flatten() {
            let path = entry.path();
            if path.extension().map_or(false, |e| e == "toml") {
                println!("cargo:rerun-if-changed={}", path.display());
                if let Ok(content) = fs::read_to_string(&path) {
                    match toml::from_str::<SawnLumberFile>(&content) {
                        Ok(data) => {
                            all_data.push((data.metadata, data.species));
                        }
                        Err(e) => {
                            eprintln!("Warning: Failed to parse {}: {}", path.display(), e);
                        }
                    }
                }
            }
        }
    }

    if all_data.is_empty() {
        return None;
    }

    // Generate Rust code
    let mut code = String::new();
    code.push_str("pub mod sawn_lumber_data {\n");
    code.push_str("    //! Auto-generated sawn lumber reference design values\n");
    code.push_str("    //!\n");

    // Add provenance comments
    for (meta, _) in &all_data {
        code.push_str(&format!("    //! Source: {} {} ({})\n",
            meta.source, meta.table, meta.edition_year));
    }
    code.push_str("\n");

    // Generate lookup function
    code.push_str("    use std::collections::HashMap;\n");
    code.push_str("    use once_cell::sync::Lazy;\n\n");

    code.push_str("    #[derive(Debug, Clone, Copy)]\n");
    code.push_str("    pub struct SawnLumberProps {\n");
    code.push_str("        pub fb_psi: f64,\n");
    code.push_str("        pub ft_psi: f64,\n");
    code.push_str("        pub fv_psi: f64,\n");
    code.push_str("        pub fc_perp_psi: f64,\n");
    code.push_str("        pub fc_psi: f64,\n");
    code.push_str("        pub e_psi: f64,\n");
    code.push_str("        pub e_min_psi: f64,\n");
    code.push_str("        pub specific_gravity: f64,\n");
    code.push_str("    }\n\n");

    // Generate static data
    code.push_str("    pub static SAWN_LUMBER: Lazy<HashMap<(&'static str, &'static str), SawnLumberProps>> = Lazy::new(|| {\n");
    code.push_str("        let mut m = HashMap::new();\n");

    for (_, species_list) in &all_data {
        for species in species_list {
            for grade in &species.grades {
                code.push_str(&format!(
                    "        m.insert((\"{}\", \"{}\"), SawnLumberProps {{\n",
                    species.code, grade.code
                ));
                code.push_str(&format!("            fb_psi: {:.1},\n", grade.fb_psi));
                code.push_str(&format!("            ft_psi: {:.1},\n", grade.ft_psi));
                code.push_str(&format!("            fv_psi: {:.1},\n", grade.fv_psi));
                code.push_str(&format!("            fc_perp_psi: {:.1},\n", grade.fc_perp_psi));
                code.push_str(&format!("            fc_psi: {:.1},\n", grade.fc_psi));
                code.push_str(&format!("            e_psi: {:.1},\n", grade.e_psi));
                code.push_str(&format!("            e_min_psi: {:.1},\n", grade.e_min_psi));
                code.push_str(&format!("            specific_gravity: {:.2},\n", grade.specific_gravity));
                code.push_str("        });\n");
            }
        }
    }

    code.push_str("        m\n");
    code.push_str("    });\n\n");

    // Generate lookup helper
    code.push_str("    pub fn lookup(species_code: &str, grade_code: &str) -> Option<SawnLumberProps> {\n");
    code.push_str("        SAWN_LUMBER.get(&(species_code, grade_code)).copied()\n");
    code.push_str("    }\n");

    code.push_str("}\n\n");

    Some(code)
}

// ============================================================================
// Engineered Wood Processing (LVL, PSL, LSL)
// ============================================================================

#[derive(Debug, Deserialize)]
struct EngineeredWoodFile {
    metadata: EngineeredMetadata,
    #[serde(default)]
    products: Vec<EngineeredProduct>,
}

#[derive(Debug, Deserialize)]
struct EngineeredMetadata {
    source: String,
    product_type: String,  // "LVL", "PSL", "LSL", "Glulam"
    manufacturer: Option<String>,
    #[allow(dead_code)]
    evaluation_report: Option<String>,
    #[allow(dead_code)]
    transcribed_date: Option<String>,
}

#[derive(Debug, Deserialize)]
struct EngineeredProduct {
    #[allow(dead_code)]
    name: String,
    code: String,
    #[serde(rename = "Fb")]
    fb_psi: f64,
    #[serde(rename = "Ft")]
    ft_psi: f64,
    #[serde(rename = "Fv")]
    fv_psi: f64,
    #[serde(rename = "Fc_perp")]
    fc_perp_psi: f64,
    #[serde(rename = "Fc")]
    fc_psi: f64,
    #[serde(rename = "E")]
    e_psi: f64,
    #[serde(rename = "Emin")]
    e_min_psi: f64,
    #[serde(rename = "SG")]
    specific_gravity: f64,
    #[serde(default)]
    depth_factor_exponent: Option<f64>,  // For depth adjustment: (12/d)^exp
}

// ============================================================================
// Glulam Processing (separate schema with Fb_pos/Fb_neg)
// ============================================================================

#[derive(Debug, Deserialize)]
struct GlulamFile {
    metadata: GlulamMetadata,
    #[serde(default)]
    products: Vec<GlulamProduct>,
}

#[derive(Debug, Deserialize)]
struct GlulamMetadata {
    source: String,
    #[allow(dead_code)]
    product_type: String,  // Should be "Glulam"
    #[allow(dead_code)]
    transcribed_date: Option<String>,
    #[allow(dead_code)]
    verified_against: Option<String>,
    #[allow(dead_code)]
    notes: Option<String>,
}

#[derive(Debug, Deserialize)]
struct GlulamProduct {
    #[allow(dead_code)]
    name: String,
    code: String,
    #[serde(rename = "Fb_pos")]
    fb_pos_psi: f64,
    #[serde(rename = "Fb_neg")]
    fb_neg_psi: f64,
    #[serde(rename = "Ft")]
    ft_psi: f64,
    #[serde(rename = "Fv")]
    fv_psi: f64,
    #[serde(rename = "Fc_perp")]
    fc_perp_psi: f64,
    #[serde(rename = "Fc")]
    fc_psi: f64,
    #[serde(rename = "E")]
    e_psi: f64,
    #[serde(rename = "Emin")]
    e_min_psi: f64,
    #[serde(rename = "SG")]
    specific_gravity: f64,
    #[serde(default)]
    is_balanced: bool,
}

fn process_engineered_wood(data_dir: &Path) -> Option<String> {
    let eng_dir = data_dir.join("engineered");
    if !eng_dir.exists() {
        return None;
    }

    let mut lvl_psl_data: HashMap<String, Vec<(EngineeredMetadata, Vec<EngineeredProduct>)>> = HashMap::new();
    let mut glulam_data: Vec<(GlulamMetadata, Vec<GlulamProduct>)> = Vec::new();

    // Process all TOML files in engineered directory
    fn process_dir(
        dir: &Path,
        lvl_psl_data: &mut HashMap<String, Vec<(EngineeredMetadata, Vec<EngineeredProduct>)>>,
        glulam_data: &mut Vec<(GlulamMetadata, Vec<GlulamProduct>)>,
    ) {
        if let Ok(entries) = fs::read_dir(dir) {
            for entry in entries.flatten() {
                let path = entry.path();
                if path.is_dir() {
                    process_dir(&path, lvl_psl_data, glulam_data);
                } else if path.extension().map_or(false, |e| e == "toml") {
                    println!("cargo:rerun-if-changed={}", path.display());
                    if let Ok(content) = fs::read_to_string(&path) {
                        // Try parsing as Glulam first (has Fb_pos/Fb_neg)
                        if let Ok(data) = toml::from_str::<GlulamFile>(&content) {
                            if data.metadata.product_type == "Glulam" {
                                glulam_data.push((data.metadata, data.products));
                                continue;
                            }
                        }
                        // Otherwise try as LVL/PSL/LSL
                        match toml::from_str::<EngineeredWoodFile>(&content) {
                            Ok(data) => {
                                let product_type = data.metadata.product_type.clone();
                                lvl_psl_data.entry(product_type)
                                    .or_default()
                                    .push((data.metadata, data.products));
                            }
                            Err(e) => {
                                eprintln!("Warning: Failed to parse {}: {}", path.display(), e);
                            }
                        }
                    }
                }
            }
        }
    }

    process_dir(&eng_dir, &mut lvl_psl_data, &mut glulam_data);

    if lvl_psl_data.is_empty() && glulam_data.is_empty() {
        return None;
    }

    // Generate Rust code
    let mut code = String::new();
    code.push_str("pub mod engineered_wood_data {\n");
    code.push_str("    //! Auto-generated engineered wood reference design values\n\n");

    code.push_str("    use std::collections::HashMap;\n");
    code.push_str("    use once_cell::sync::Lazy;\n\n");

    // EngineeredWoodProps for LVL/PSL/LSL
    code.push_str("    #[derive(Debug, Clone, Copy)]\n");
    code.push_str("    pub struct EngineeredWoodProps {\n");
    code.push_str("        pub fb_psi: f64,\n");
    code.push_str("        pub ft_psi: f64,\n");
    code.push_str("        pub fv_psi: f64,\n");
    code.push_str("        pub fc_perp_psi: f64,\n");
    code.push_str("        pub fc_psi: f64,\n");
    code.push_str("        pub e_psi: f64,\n");
    code.push_str("        pub e_min_psi: f64,\n");
    code.push_str("        pub specific_gravity: f64,\n");
    code.push_str("        pub depth_factor_exponent: Option<f64>,\n");
    code.push_str("    }\n\n");

    // GlulamProps with Fb_pos and Fb_neg
    code.push_str("    #[derive(Debug, Clone, Copy)]\n");
    code.push_str("    pub struct GlulamProps {\n");
    code.push_str("        pub fb_pos_psi: f64,\n");
    code.push_str("        pub fb_neg_psi: f64,\n");
    code.push_str("        pub ft_psi: f64,\n");
    code.push_str("        pub fv_psi: f64,\n");
    code.push_str("        pub fc_perp_psi: f64,\n");
    code.push_str("        pub fc_psi: f64,\n");
    code.push_str("        pub e_psi: f64,\n");
    code.push_str("        pub e_min_psi: f64,\n");
    code.push_str("        pub specific_gravity: f64,\n");
    code.push_str("    }\n\n");

    // Generate static data for LVL/PSL/LSL
    for (product_type, data_list) in &lvl_psl_data {
        let var_name = product_type.to_uppercase();
        code.push_str(&format!("    pub static {}: Lazy<HashMap<&'static str, EngineeredWoodProps>> = Lazy::new(|| {{\n", var_name));
        code.push_str("        let mut m = HashMap::new();\n");

        for (meta, products) in data_list {
            code.push_str(&format!("        // Source: {} ({})\n",
                meta.source,
                meta.manufacturer.as_deref().unwrap_or("generic")));

            for product in products {
                code.push_str(&format!("        m.insert(\"{}\", EngineeredWoodProps {{\n", product.code));
                code.push_str(&format!("            fb_psi: {:.1},\n", product.fb_psi));
                code.push_str(&format!("            ft_psi: {:.1},\n", product.ft_psi));
                code.push_str(&format!("            fv_psi: {:.1},\n", product.fv_psi));
                code.push_str(&format!("            fc_perp_psi: {:.1},\n", product.fc_perp_psi));
                code.push_str(&format!("            fc_psi: {:.1},\n", product.fc_psi));
                code.push_str(&format!("            e_psi: {:.1},\n", product.e_psi));
                code.push_str(&format!("            e_min_psi: {:.1},\n", product.e_min_psi));
                code.push_str(&format!("            specific_gravity: {:.2},\n", product.specific_gravity));
                match product.depth_factor_exponent {
                    Some(exp) => code.push_str(&format!("            depth_factor_exponent: Some({:.3}),\n", exp)),
                    None => code.push_str("            depth_factor_exponent: None,\n"),
                }
                code.push_str("        });\n");
            }
        }

        code.push_str("        m\n");
        code.push_str("    });\n\n");
    }

    // Generate static data for Glulam
    if !glulam_data.is_empty() {
        code.push_str("    pub static GLULAM: Lazy<HashMap<&'static str, GlulamProps>> = Lazy::new(|| {\n");
        code.push_str("        let mut m = HashMap::new();\n");

        for (meta, products) in &glulam_data {
            code.push_str(&format!("        // Source: {}\n", meta.source));

            for product in products {
                code.push_str(&format!("        m.insert(\"{}\", GlulamProps {{\n", product.code));
                code.push_str(&format!("            fb_pos_psi: {:.1},\n", product.fb_pos_psi));
                code.push_str(&format!("            fb_neg_psi: {:.1},\n", product.fb_neg_psi));
                code.push_str(&format!("            ft_psi: {:.1},\n", product.ft_psi));
                code.push_str(&format!("            fv_psi: {:.1},\n", product.fv_psi));
                code.push_str(&format!("            fc_perp_psi: {:.1},\n", product.fc_perp_psi));
                code.push_str(&format!("            fc_psi: {:.1},\n", product.fc_psi));
                code.push_str(&format!("            e_psi: {:.1},\n", product.e_psi));
                code.push_str(&format!("            e_min_psi: {:.1},\n", product.e_min_psi));
                code.push_str(&format!("            specific_gravity: {:.2},\n", product.specific_gravity));
                code.push_str("        });\n");
            }
        }

        code.push_str("        m\n");
        code.push_str("    });\n\n");

        // Add lookup helper for Glulam
        code.push_str("    pub fn lookup_glulam(stress_class: &str) -> Option<GlulamProps> {\n");
        code.push_str("        GLULAM.get(stress_class).copied()\n");
        code.push_str("    }\n\n");
    }

    // Add lookup helpers for LVL/PSL
    code.push_str("    pub fn lookup_lvl(grade: &str) -> Option<EngineeredWoodProps> {\n");
    code.push_str("        LVL.get(grade).copied()\n");
    code.push_str("    }\n\n");

    code.push_str("    pub fn lookup_psl(grade: &str) -> Option<EngineeredWoodProps> {\n");
    code.push_str("        PSL.get(grade).copied()\n");
    code.push_str("    }\n");

    code.push_str("}\n");

    Some(code)
}
